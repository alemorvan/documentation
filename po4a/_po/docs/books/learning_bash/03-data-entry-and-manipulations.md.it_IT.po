# Italian translations for po package
# Traduzioni italiane per il pacchetto po.
# Copyright (C) 2023 Free Software Foundation, Inc.
# This file is distributed under the same license as the po package.
# Automatically generated, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: po 4a\n"
"POT-Creation-Date: 2023-06-11 15:28+0000\n"
"PO-Revision-Date: 2023-06-11 15:28+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: it\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. type: YAML Front Matter: tags
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:1
#, no-wrap
msgid "education"
msgstr ""

#. type: YAML Front Matter: tags
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:1
#, no-wrap
msgid "bash scripting"
msgstr ""

#. type: YAML Front Matter: tags
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:1
#, no-wrap
msgid "bash"
msgstr ""

#. type: Title #
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:1
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:12
#, no-wrap
msgid "Bash - Data entry and manipulations"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:15
msgid ""
"In this chapter you will learn how to make your scripts interact with users "
"and manipulate the data."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:19
#, no-wrap
msgid "**Objectives**: In this chapter you will learn how to:\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:24
#, no-wrap
msgid ""
":heavy_check_mark: read input from a user;     \n"
":heavy_check_mark: manipulate data entries;     \n"
":heavy_check_mark: use arguments inside a script;     \n"
":heavy_check_mark: manage positional variables;     \n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:26
msgid ":checkered_flag: **linux**, **script**, **bash**, **variable**"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:27
#, no-wrap
msgid "**Knowledge**: :star: :star:  \n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:28
#, no-wrap
msgid "**Complexity**: :star: :star:  \n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:31
#, no-wrap
msgid "**Reading time**: 10 minutes\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:35
msgid ""
"Depending on the purpose of the script, it may be necessary to send it "
"information when it is launched or during its execution. This information, "
"not known when the script is written, can be extracted from files or entered "
"by the user. It is also possible to send this information in the form of "
"arguments when the script command is entered. This is the way many Linux "
"commands work."
msgstr ""

#. type: Title ##
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:36
#, no-wrap
msgid "The `read` command"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:39
msgid ""
"The `read` command allows you to enter a character string and store it in a "
"variable."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:41
msgid "Syntax of the read command:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:42
#, no-wrap
msgid "read [-n X] [-p] [-s] [variable]\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:47
msgid ""
"The first example below, prompts you for two variable inputs: \"name\" and "
"\"firstname\", but since there is no prompt, you would have to know ahead of "
"time that this was the case. In the case of this particular entry, each "
"variable input would be separated by a space.  The second example prompts "
"for the variable \"name\" with the prompt text included:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:48
#, no-wrap
msgid ""
"read name firstname\n"
"read -p \"Please type your name: \" name\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:58
#, no-wrap
msgid ""
"| Option | Observation                                   |\n"
"|--------|-----------------------------------------------|\n"
"| `-p`   | Displays a prompt message.                    |\n"
"| `-n`   | Limit the number of characters to be entered. |\n"
"| `-s`   | Hides the input.                              |\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:60
#, no-wrap
msgid "When using the `-n` option, the shell automatically validates the input after the specified number of characters. The user does not have to press the <kbd>ENTER</kbd> key.\n"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:61
#, no-wrap
msgid "read -n5 name\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:66
msgid ""
"The `read` command allows you to interrupt the execution of the script while "
"the user enters information. The user's input is broken down into words "
"assigned to one or more predefined variables. The words are strings of "
"characters separated by the field separator."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:68
#, no-wrap
msgid "The end of the input is determined by pressing the <kbd>ENTER</kbd> key.\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:70
msgid ""
"Once the input is validated, each word will be stored in the predefined "
"variable."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:73
msgid ""
"The division of the words is defined by the field separator character.  This "
"separator is stored in the system variable `IFS` (**Internal Field "
"Separator**)."
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:74
#, no-wrap
msgid ""
"set | grep IFS\n"
"IFS=$' \\t\\n'\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:80
msgid "By default, the IFS contains the space, tab and line feed."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:82
msgid ""
"When used without specifying a variable, this command simply pauses the "
"script. The script continues its execution when the input is validated."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:84
#, no-wrap
msgid "This is used to pause a script when debugging or to prompt the user to press <kbd>ENTER</kbd> to continue.\n"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:85
#, no-wrap
msgid ""
"echo -n \"Press [ENTER] to continue...\"\n"
"read\n"
msgstr ""

#. type: Title ##
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:90
#, no-wrap
msgid "The `cut` command"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:93
msgid ""
"The cut command allows you to isolate a column in a file or in a stream."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:95
msgid "Syntax of the cut command:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:96
#, no-wrap
msgid "cut [-cx] [-dy] [-fz] file\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:101
msgid "Example of use of the cut command:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:102
#, no-wrap
msgid "cut -d: -f1 /etc/passwd\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:111
#, no-wrap
msgid ""
"| Option | Observation                                                      |\n"
"|--------|------------------------------------------------------------------|\n"
"| `-c`   | Specifies the sequence numbers of the characters to be selected. |\n"
"| `-d`   | Specifies the field separator.                                   |\n"
"| `-f`   | Specifies the order number of the columns to select.             |\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:113
msgid ""
"The main interest of this command will be its association with a stream, for "
"example the `grep` command and the `|` pipe."
msgstr ""

#. type: Bullet: '* '
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:116
msgid ""
"The `grep` command works \"vertically\" (isolation of one line from all the "
"lines in the file)."
msgstr ""

#. type: Bullet: '* '
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:116
msgid ""
"The combination of the two commands allows for the **isolation of a specific "
"field in the file**."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:118
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:216
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:338
msgid "Example:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:119
#, no-wrap
msgid ""
"grep \"^root:\" /etc/passwd | cut -d: -f3\n"
"0\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:125
msgid "!!! NOTE"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:127
#, no-wrap
msgid "    Configuration files with a single structure using the same field separator are ideal targets for this combination of commands.\n"
msgstr ""

#. type: Title ##
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:128
#, no-wrap
msgid "The `tr` command"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:131
msgid "The `tr` command allows you to convert a string."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:133
msgid "Syntax of the `tr` command:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:134
#, no-wrap
msgid "tr [-csd] string1 string2\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:143
#, no-wrap
msgid ""
"| Option | Observation                                                                                            |\n"
"|--------|--------------------------------------------------------------------------------------------------------|\n"
"| `-c`   | All characters not specified in the first string are converted to the characters of the second string. |\n"
"| `-d`   | Deletes the specified character.                                                                       |\n"
"| `-s`   | Reduce the specified character to a single unit.                                                       |\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:145
msgid ""
"An example of using the `tr` command follows. If you use `grep` to return "
"root's `passwd` file entry, you would get this:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:146
#, no-wrap
msgid "grep root /etc/passwd\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:150
msgid "returns:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:150
#, no-wrap
msgid "root:x:0:0:root:/root:/bin/bash\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:154
msgid "Now let's use `tr` command and the reduce the \"o's\" in the line:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:155
#, no-wrap
msgid "grep root /etc/passwd | tr -s \"o\"\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:159
msgid "which returns this:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:159
#, no-wrap
msgid "rot:x:0:0:rot:/rot:/bin/bash\n"
msgstr ""

#. type: Title ##
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:162
#, no-wrap
msgid "Extract the name and path of a file"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:165
msgid ""
"The `basename` command allows you to extract the name of the file from a "
"path."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:167
msgid "The `dirname` command allows you to extract the parent path of a file."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:169
msgid "Examples:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:170
#, no-wrap
msgid ""
"echo $FILE=/usr/bin/passwd\n"
"basename $FILE\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:175
msgid "Which would result in \"passwd\""
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:175
#, no-wrap
msgid "dirname $FILE\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:179
msgid "Which would result in: \"/usr/bin\""
msgstr ""

#. type: Title ##
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:180
#, no-wrap
msgid "Arguments of a script"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:183
msgid ""
"The request to enter information with the `read` command interrupts the "
"execution of the script as long as the user does not enter any information."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:186
msgid ""
"This method, although very user-friendly, has its limits if the script is "
"scheduled to run at night.  To overcome this problem, it is possible to "
"inject the desired information via arguments."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:188
msgid "Many Linux commands work on this principle."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:190
msgid ""
"This way of doing things has the advantage that once the script is executed, "
"it will not need any human intervention to finish."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:192
msgid ""
"Its major disadvantage is that the user will have to be warned about the "
"syntax of the script to avoid errors."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:195
msgid ""
"The arguments are filled in when the script command is entered.  They are "
"separated by a space."
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:196
#, no-wrap
msgid "./script argument1 argument2\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:201
msgid ""
"Once executed, the script saves the entered arguments in predefined "
"variables: `positional variables`."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:203
msgid ""
"These variables can be used in the script like any other variable, except "
"that they cannot be assigned."
msgstr ""

#. type: Bullet: '* '
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:206
msgid "Unused positional variables exist but are empty."
msgstr ""

#. type: Bullet: '* '
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:206
msgid "Positional variables are always defined in the same way:"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:214
#, no-wrap
msgid ""
"| Variable     | Observation                                             |\n"
"|--------------|---------------------------------------------------------|\n"
"| `$0`         | contains the name of the script as entered.             |\n"
"| `$1` to `$9` | contain the values of the 1st to 9th argument           |\n"
"| `${x}`       | contains the value of the argument `x`, greater than 9. |\n"
"| `$#`         | contains the number of arguments passed.                |\n"
"| `$*` or `$@` | contains in one variable all the arguments passed.      |\n"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:217
#, no-wrap
msgid ""
"#!/usr/bin/env bash\n"
"#\n"
"# Author : Damien dit LeDub\n"
"# Date : september 2019\n"
"# Version 1.0.0 : Display the value of the positional arguments\n"
"# From 1 to 3\n"
"\n"
"# The field separator will be \",\" or space\n"
"# Important to see the difference in $* and $@\n"
"IFS=\", \"\n"
"\n"
"# Display a text on the screen:\n"
"echo \"The number of arguments (\\$#) = $#\"\n"
"echo \"The name of the script  (\\$0) = $0\"\n"
"echo \"The 1st argument        (\\$1) = $1\"\n"
"echo \"The 2nd argument        (\\$2) = $2\"\n"
"echo \"The 3rd argument        (\\$3) = $3\"\n"
"echo \"All separated by IFS    (\\$*) = $*\"\n"
"echo \"All without separation  (\\$@) = $@\"\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:240
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:301
msgid "This will give:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:241
#, no-wrap
msgid ""
"$ ./arguments.sh one two \"tree four\"\n"
"The number of arguments ($#) = 3\n"
"The name of the script  ($0) = ./arguments.sh\n"
"The 1st argument        ($1) = one\n"
"The 2nd argument        ($2) = two\n"
"The 3rd argument        ($3) = tree four\n"
"All separated by IFS    ($*) = one,two,tree four\n"
"All without separation  ($@) = one two tree four\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:253
msgid "!!! warning"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:255
#, no-wrap
msgid "    Beware of the difference between `$@` and `$*`. It is in the argument storage format:\n"
msgstr ""

#. type: Bullet: '    * '
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:258
msgid "`$*` : Contains the arguments in the format `\"$1 $2 $3 ...\"`"
msgstr ""

#. type: Bullet: '    * '
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:258
msgid "`$@` : Contains arguments in the format `\"$1\" \"$2\" \"$3\" ...`"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:260
#, no-wrap
msgid "    It is by modifying the `IFS` environment variable that the difference is visible.\n"
msgstr ""

#. type: Title ###
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:261
#, no-wrap
msgid "The shift command"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:264
msgid "The shift command allows you to shift positional variables."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:266
msgid ""
"Let's modify our previous example to illustrate the impact of the shift "
"command on positional variables:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:267
#, no-wrap
msgid ""
"#!/usr/bin/env bash\n"
"#\n"
"# Author : Damien dit LeDub\n"
"# Date : september 2019\n"
"# Version 1.0.0 : Display the value of the positional arguments\n"
"# From 1 to 3\n"
"\n"
"# The field separator will be \",\" or space\n"
"# Important to see the difference in $* and $@\n"
"IFS=\", \"\n"
"\n"
"# Display a text on the screen:\n"
"echo \"The number of arguments (\\$#) = $#\"\n"
"echo \"The 1st argument        (\\$1) = $1\"\n"
"echo \"The 2nd argument        (\\$2) = $2\"\n"
"echo \"The 3rd argument        (\\$3) = $3\"\n"
"echo \"All separated by IFS    (\\$*) = $*\"\n"
"echo \"All without separation  (\\$@) = $@\"\n"
"\n"
"shift 2\n"
"echo \"\"\n"
"echo \"-------- SHIFT 2 ----------------\"\n"
"echo \"\"\n"
"\n"
"echo \"The number of arguments (\\$#) = $#\"\n"
"echo \"The 1st argument        (\\$1) = $1\"\n"
"echo \"The 2nd argument        (\\$2) = $2\"\n"
"echo \"The 3rd argument        (\\$3) = $3\"\n"
"echo \"All separated by IFS    (\\$*) = $*\"\n"
"echo \"All without separation  (\\$@) = $@\"\n"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:302
#, no-wrap
msgid ""
"./arguments.sh one two \"tree four\"\n"
"The number of arguments ($#) = 3\n"
"The 1st argument        ($1) = one\n"
"The 2nd argument        ($2) = two\n"
"The 3rd argument        ($3) = tree four\n"
"All separated by IFS    ($*) = one,two,tree four\n"
"All without separation  ($@) = one two tree four\n"
"\n"
"-------- SHIFT 2 ----------------\n"
"\n"
"The number of arguments ($#) = 1\n"
"The 1st argument        ($1) = tree four\n"
"The 2nd argument        ($2) =\n"
"The 3rd argument        ($3) =\n"
"All separated by IFS    ($*) = tree four\n"
"All without separation  ($@) = tree four\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:322
msgid ""
"As you can see, the `shift` command has shifted the place of the arguments "
"\"to the left\", removing the first 2."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:324
msgid "!!! WARNING"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:326
#, no-wrap
msgid "    When using the `shift` command, the `$#` and `$*` variables are modified accordingly.\n"
msgstr ""

#. type: Title ###
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:327
#, no-wrap
msgid "The `set` command"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:330
msgid "The `set` command splits a string into positional variables."
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:332
msgid "Syntax of the set command:"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:333
#, no-wrap
msgid "set [value] [$variable]\n"
msgstr ""

#. type: Fenced code block
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:339
#, no-wrap
msgid ""
"$ set one two three\n"
"$ echo $1 $2 $3 $#\n"
"one two three 3\n"
"$ variable=\"four five six\"\n"
"$ set $variable\n"
"$ echo $1 $2 $3 $#\n"
"four five six 3\n"
msgstr ""

#. type: Plain text
#: ../src/docs/books/learning_bash/03-data-entry-and-manipulations.md:349
msgid "You can now use positional variables as seen before."
msgstr ""
